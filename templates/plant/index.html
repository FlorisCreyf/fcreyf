<!DOCTYPE html>
<html>
	<head>
		<title>Plant Generator</title>
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="{{ url_for('static', filename='plant/main.css') }}">
		<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,300,600" rel="stylesheet" type="text/css">
	</head>
  <body>
		{% include "plant/header.html" %}
		<div id="overview">
			<div class="center">
				<h1>Plant Generator</h1>
				<p>The purpose of Plant Generator is to generate geometry. It should be able to automatically find optimal configurations for points, triangles, and texture coordinates.</p>
			</div>
		</div>
		<div class="center">
			<h2 id="download">Download</h2>
			<ul id="download-items">
				<li><a href="{{ url_for('static', filename='plant/plant-generator-x64.tar.xz') }}">Linux (x64)</a></li><!--
				--><li><a href="{{ url_for('static', filename='plant/plant-generator-win-x64.zip') }}">Windows (x64)</a></li><!--
				--><li><a href="https://github.com/floriscreyf/plant-generator">Repository</a></li>
			</ul>
			<div id="clone"><div>git clone https://github.com/floriscreyf/plant-generator.git --recursive</div></div>
		</div>
		<div id="screenshots" class="center">
			<h2>Screenshots</h2>
			<div id="images">
				<img src="{{ url_for('static', filename='plant/pg1.png') }}"><img src="{{ url_for('static', filename='plant/pg.png') }}">
			</div>
		</div>
		<div id="docs" class="center">
			<h2 id="documentation">Documentation</h2>
			<ul id="docs-items">
				<li><a href="#editor">Editor</a></li><li><a href="#generator">Generator</a></li><li><a href="#shaders">Shaders</a></li>
			</ul>
			<h3>Introduction</h3>
			<div class="left">
				<p>The project is split in two parts. The editor component handles all user input and provides realtime feedback. The generator component defines and generates the plant structure and is used to create a plant mesh. It is intended that the generator is removable from the editor so that it can be used as a library instead.</p>
			</div><div class="right">
				<img src="{{ url_for('static', filename='plant/intro.svg') }}">
			</div>
			<h3 id="editor">Editor</h3>
			<div class="left">
				<h4>Camera</h4>
				<p>The camera produces matrices for transforming the world space into the screen space. Points can be transformed so that either a perspective or orthographic view is created. The camera also produces inverse matrices so that the screen space can be transformed back into the world space. This is useful for object selection.</p>
				<p>The variables listed below determine the positioning and orientation of the camera.</p>
				<ul>
					<li><span>Vec3 target</span> – The point the camera is pointed at.</li>
					<li><span>float distance</span> – The distance the camera is from the target.</li>
					<li><span>float x</span> – A rotation around the x-axis.</li>
					<li><span>float y</span> – A rotation around the y-axis.</li>
				</ul>
				<p>The x and y rotations are used to calculate a point on a sphere. The location of the camera is then: <span>(location on sphere) (distance) + target</span>. The x and y rotations are also used to maintain the orientation of the camera even when the direction and up vectors are parallel.</p>
				<img src="{{ url_for('static', filename='plant/camera.svg') }}">
			</div><div class="right">
				<h4>Commands</h4>
				<p>The editor uses the command pattern to store all user invocable commands. This allows each command to be easily associated with a key combination, and makes it possible to implement an undo/redo system without having to copy the entire application state. Commands are required to be able to execute, undo, and then redo themselves using the execute function. The downside of this approach is that if a command improperly undoes its changes, then the undo behavior of prior commands will also be faulty.</p>
				<h5>Move Commands</h5>
				<p>In order to move an object in the world space using the cursor, the cursor position is converted into a ray pointing into the world space. The ray is used to create a point in the world space by intersecting with a plane that is parallel to the camera direction. Points are moved by the difference of the initial and last (cursor generated) points.</p>
				<p>There is also a need to move points along paths instead of straight through the world space. This functions differently from the first method. Instead of converting the cursor position to a point in the world space, the points along the path are converted to the screen space. The cursor position is projected onto the (now two-dimensional) path to determine a new point.</p>
				<h5>Save Commands</h5>
				<p>The internal properties of stems and leaves can be adjusted using a property editor. The program checks for changes within the selection whenever a property editor loses focus. A command storing the previous objects is inserted into the history if changes were made.</p>
			</div>
			<div class="left">
				<h4>Resources</h4>
				<p>The editor stores a SharedResources object that stores all the shaders and materials that are needed across all OpenGL widgets. Default images are automatically loaded from the resources file, and shaders are automatically loaded from the shaders file. The SharedResources object also keeps track of all materials. Signals are emitted when materials are edited.</p>
			</div><div class="right">
				<h4>History</h4>
				<p>The history maintains a list of past and future commands. Selection information is also stored within commands, and changing the selection will clear the future list.</p>
			</div>
			<h3 id="generator">3 Generator</h3>
			<div class="left">
				<h4>Stems</h4>
				<p>The positions of stems are stored as distances along parent stems. Stems internally calculate vector positions (<i>i.e.</i> locations in world space) when distances are changed and when paths of ancestor stems are changed.</p>
				<h5>Bark Ridges and Branch Collars</h5>
				<p>The branch collar is a swelling at the base of the stem. It is generated by scaling the stem, intersecting the stem, and generating a spline to create smooth transitions from the intersection points.</p>
				<h5>Stem Forking</h5>
				<p><span class="todo">TODO</span> A plant that has little apical dominance has more forks in its structure. Auxin is a hormone that surpresses the growth of lateral branches. Therefore, the less a plant produces auxin, the less likely there will be a central leader.</p>
			</div><div class="right">
				<h4>Leaves</h4>
				<p>The position of leaves is stored as the distance along the parent stem. Since leaves do not know about their parent stems, the world position of the leaf can only be determined if the parent stem is also known.</p>
				<p>The orientation of leaves is more complicated than that of stems. This is because stems are represented as two dimensional lines, whereas leaves are represented as three dimensional objects. An additional set of rotations is applied to each leaf so that all leaves by default point upward. Finally, all leaf rotations are represented using quaternions. Subsequently concatenating Euler rotations cause gimbal lock if a leaf is rotated by 90 degrees around one axis. Quaternions provide more desirable behavior.</p>
			</div>
			<div class="left">
				<h4>Materials and Textures</h4>
				<p>The plant object stores a list of all materials that stems and leaves can have. Stems and leaves store IDs of materials (instead of actual material objects), so materials only have to be updated in the plant object. An ID with a value of zero means that the stem or leaf has no material.</p>
				<p>The geometry generator needs to create vertex seams (<i>i.e.</i> duplicate vertices) so that textures can be wraped around the stems. Vertex seams might not be needed if a special fragment shader is used.</p>
			</div><div class="right">
				<h4>Meshes</h4>
				<p>Each leaf has a reference to a mesh, where each mesh consists of an arbitrary set of points, texture coordinates, and indices. These meshes are stored within the plant object and are inserted into the plant geometry during generation.</p>
			</div>
			<h3 id="shaders">Shaders</h3>
			<div class="left">
				<h4>Outlines</h4>
				<p>Selected objects are indicated with an outline around their silhouette. The outline is achieved in two passes. The first pass draws the selected objects offscreen in solid white onto a black background. This image is stored in a texture for the second pass. During the second pass, the fragment shader refers to this texture to determine if a fragment is close to the object’s silhouette edge. Even though the fragment shader needs to scan and analyze the texture, it needs to avoid branch divergence in order to keep performance acceptable.</p>
			</div>
		</div>
	</body>
</html>
